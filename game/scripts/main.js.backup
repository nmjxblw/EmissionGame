const CONFIG = {
  SCREEN_WIDTH: 540,
  SCREEN_HEIGHT: 960,
  GRID_SIZE: 10,
  STORAGE_KEY: "pixel_tactics_save_v1",
  MAX_SPEED: 100,
  MIN_SPEED: 1,
  BASE_AP_GOAL: 1000,
  LANGUAGE: "zh_cn",
  ELEMENTS: {
    FIRE: "fire",
    WATER: "water",
    LEAF: "leaf",
    LIGHT: "light",
    DARK: "dark",
    NONE: "none",
  },
  COLORS: {
    fire: "#ff4444",
    water: "#44aaff",
    leaf: "#88cc44",
    light: "#ffee66",
    dark: "#aa44cc",
    none: "#cccccc",
  },
  POSITIONS: {
    PLAYER: {
      ACTIVE: { left: "160px", bottom: "100px", zIndex: 50 },
    },
    ENEMY: {
      ACTIVE: { right: "160px", bottom: "100px", zIndex: 50 },
    },
  },
};

// 数据库将从 CSV 文件动态加载
// 使用 dataLoader.getCharacter(code) 和 dataLoader.getEnemy(code)

class SoundManager {
  static ctx = null;
  static volume = 0.5;
  static bgmInterval = null;
  static init() {
    if (!this.ctx) {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    }
  }
  static setVolume(val) {
    this.volume = val;
  }
  static playTone(freq, type, duration, volMod = 1) {
    if (!this.ctx || this.volume <= 0) return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
    gain.gain.setValueAtTime(this.volume * volMod, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(
      0.01,
      this.ctx.currentTime + duration,
    );
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start();
    osc.stop(this.ctx.currentTime + duration);
  }
  static playNoise(duration, volMod = 1) {
    if (!this.ctx || this.volume <= 0) return;
    const bufferSize = this.ctx.sampleRate * duration;
    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
    const noise = this.ctx.createBufferSource();
    noise.buffer = buffer;
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(this.volume * volMod, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(
      0.01,
      this.ctx.currentTime + duration,
    );
    noise.connect(gain);
    gain.connect(this.ctx.destination);
    noise.start();
  }
  static startBGM() {
    if (!this.ctx) this.init();
    if (this.bgmInterval) return;
    this.playBGMLoop();
  }
  static stopBGM() {
    if (this.bgmInterval) {
      clearInterval(this.bgmInterval);
      this.bgmInterval = null;
    }
  }
  static playBGMLoop() {
    if (!this.ctx) return;
    const playNote = (time, freq) => {
      if (!this.ctx) return;
      const osc = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      osc.type = "sawtooth";
      osc.frequency.value = freq;
      gain.gain.value = this.volume * 0.15;
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
      osc.connect(gain);
      gain.connect(this.ctx.destination);
      osc.start(time);
      osc.stop(time + 0.2);
    };
    const pattern = [146.83, 0, 146.83, 174.61, 220.0, 174.61, 146.83, 110.0];
    let idx = 0;
    this.bgmInterval = setInterval(() => {
      if (this.volume <= 0) return;
      const freq = pattern[idx % pattern.length];
      if (freq > 0) playNote(this.ctx.currentTime, freq);
      idx++;
    }, 200);
  }
  static playClick() {
    this.playTone(800, "square", 0.05, 0.3);
  }
  static playSwap() {
    this.playTone(300, "triangle", 0.1, 0.5);
  }
  static playMatch() {
    this.playTone(600, "sine", 0.1, 0.6);
    setTimeout(() => this.playTone(900, "sine", 0.2, 0.6), 100);
  }
  static playAttack() {
    this.playNoise(0.2, 0.8);
  }
  static playWin() {
    this.playTone(440, "square", 0.2);
    setTimeout(() => this.playTone(554, "square", 0.2), 200);
    setTimeout(() => this.playTone(659, "square", 0.4), 400);
  }
  static playDefeat() {
    this.playTone(200, "sawtooth", 0.3);
    setTimeout(() => this.playTone(150, "sawtooth", 0.5), 300);
  }
}

class Utils {
  static uuid() {
    return Math.random().toString(36).substr(2, 9);
  }
  static getText(keyOrObj, params = {}) {
    if (typeof keyOrObj === "string") {
      // 使用 i18n 管理器获取文本
      return window.i18n ? i18n.getText(keyOrObj, params) : keyOrObj;
    } else if (typeof keyOrObj === "object" && keyOrObj !== null) {
      // 兼容旧的对象格式（如角色名称）
      const langMap = { zh_cn: "zh", en_us: "en" };
      const simpleLang = langMap[CONFIG.LANGUAGE] || "zh";
      return keyOrObj[simpleLang] || keyOrObj["en"] || "?";
    }
    return keyOrObj;
  }
  static getTileSVG(type, element, isHighlighted) {
    const color = CONFIG.COLORS[element] || "#fff";
    const opacity = isHighlighted ? 1.0 : 0.6;
    const strokeColor = color;
    const strokeWidth = 8;
    const glowFilter = `drop-shadow(0 0 4px ${color}) drop-shadow(0 0 8px ${color})`;
    let shape = "";
    switch (parseInt(type)) {
      case 1:
        shape = `<path d="M50 15 L85 75 L15 75 Z" fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-linejoin="round"/>`;
        break;
      case 2:
        shape = `<path d="M50 10 L90 50 L50 90 L10 50 Z" fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-linejoin="round"/>`;
        break;
      case 3:
        shape = `<circle cx="50" cy="50" r="35" fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>`;
        break;
      case 4:
        shape = `<path d="M30 10 L70 10 L90 30 L90 70 L70 90 L30 90 L10 70 L10 30 Z" fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-linejoin="round"/>`;
        break;
      default:
        shape = `<rect x="20" y="20" width="60" height="60" fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}" rx="10" ry="10"/>`;
    }
    const roman = ["I", "II", "III", "IV"][type - 1] || "?";
    return `<svg viewBox="0 0 100 100" width="100%" height="100%" style="opacity:${opacity}; filter: ${glowFilter}; overflow: visible;">${shape}<text x="50" y="60" font-size="30" fill="white" text-anchor="middle" font-weight="bold" stroke="none" style="text-shadow: 0 0 3px #000;">${roman}</text></svg>`;
  }
  static calcDamage(
    attacker,
    target,
    skillPower,
    skillType,
    isTrueDmg,
    isShieldDmg,
  ) {
    if (!attacker || !target) return 0;
    let atk = attacker.temp.atk,
      def = target.temp.def;
    let atkMod = 1 + (attacker.temp.atkBuff || 0),
      defMod = 1 + (target.temp.defBuff || 0);
    let totalDmgMod = 1 + (attacker.temp.dmgBuff || 0);
    let dmgFactor = 5;
    let numerator = atk * atkMod * dmgFactor;
    let denominator = def * defMod + dmgFactor;
    if (denominator === 0) denominator = 1;
    let rawDmg = Math.floor((numerator / denominator) * totalDmgMod);
    let maxLimit = Math.floor((1 / 5) * target.maxHp);
    let finalDmg = Math.max(1, Math.min(maxLimit, rawDmg));
    if (isShieldDmg) return { hpDmg: 0, shieldDmg: finalDmg };
    if (isTrueDmg) return { hpDmg: finalDmg, shieldDmg: 0 };
    else {
      let shield = target.temp.shield || 0;
      let shieldDmg = Math.min(shield, finalDmg);
      let hpDmg = finalDmg - shieldDmg;
      return { hpDmg, shieldDmg };
    }
  }
}

class BattleEntity {
  constructor(id, templateId, isPlayer, position) {
    const data = isPlayer
      ? window.dataLoader
        ? dataLoader.getCharacter(templateId)
        : null
      : window.dataLoader
        ? dataLoader.getEnemy(templateId)
        : null;
    if (!data) {
      this.nameData = { en: "Unknown", zh: "未知" };
      this.baseMaxHp = 1;
      this.baseAtk = 0;
      this.baseDef = 0;
      this.baseSpd = 1;
      this.element = "none";
      this.breaks = {};
      this.actions = {};
    } else {
      this.nameData = data.name;
      this.baseMaxHp = data.hp;
      this.baseAtk = data.atk;
      this.baseDef = data.def;
      this.baseSpd = Math.max(
        CONFIG.MIN_SPEED,
        Math.min(CONFIG.MAX_SPEED, data.spd),
      );
      this.element = data.element;
      this.breaks = JSON.parse(JSON.stringify(data.breaks || {}));
      this.actions = data.actions || {};
    }
    this.id = id;
    this.templateId = templateId;
    this.isPlayer = isPlayer;
    this.position = position;
    this.currentHp = this.baseMaxHp;
    this.maxHp = this.baseMaxHp;
    this.ap = 0;
    this.isFainted = false;
    this.faintCounter = 0;
    this.reviveCount = 3;
    this.temp = {
      atk: this.baseAtk,
      def: this.baseDef,
      spd: this.baseSpd,
      atkBuff: 0,
      defBuff: 0,
      dmgBuff: 0,
      shield: 0,
      buffs: [],
    };
  }
  get name() {
    return Utils.getText(this.nameData);
  }
  resetTurn() {}
  takeDamage(hpDmg, shieldDmg, isBreak = false) {
    if (this.isFainted) return;
    this.temp.shield = Math.max(0, this.temp.shield - shieldDmg);
    this.currentHp = Math.max(0, this.currentHp - hpDmg);
    const isHeavy = isBreak || hpDmg >= this.baseMaxHp * 0.1;
    UIManager.showDamage(this.position, this.isPlayer, hpDmg, shieldDmg);
    UIManager.updateEntityStatus(this);
    UIManager.playHitAnim(this, isHeavy);
    if (this.currentHp <= 0) this.faint();
  }
  heal(amount) {
    if (this.isFainted) return;
    this.currentHp = Math.min(this.maxHp, this.currentHp + amount);
    UIManager.showFloatText(this.position, this.isPlayer, `+${amount}`, "#4f4");
    UIManager.updateEntityStatus(this);
  }
  addShield(amount) {
    if (this.isFainted) return;
    this.temp.shield += amount;
    UIManager.showFloatText(
      this.position,
      this.isPlayer,
      `Shield +${amount}`,
      "#4af",
    );
    UIManager.updateEntityStatus(this);
  }
  faint() {
    this.isFainted = true;
    this.currentHp = 0;
    this.ap = 0;
    this.temp.shield = 0;
    this.temp.buffs = [];
    UIManager.updateEntityStatus(this);
    UIManager.playDeathAnim(this);
    UIManager.log(`${this.name} ${Utils.getText("fainted")}`);
  }
  tryRevive() {
    if (this.reviveCount > 0) {
      this.faintCounter++;
      UIManager.showFloatText(
        this.position,
        this.isPlayer,
        `${Utils.getText("revive")} ${this.faintCounter}/5`,
        "#fff",
      );
      if (this.faintCounter >= 5) {
        this.isFainted = false;
        this.currentHp = Math.floor(this.maxHp / 2);
        this.reviveCount--;
        this.faintCounter = 0;
        UIManager.reviveEntity(this);
        UIManager.log(`${this.name} ${Utils.getText("revived")}`);
        UIManager.updateEntityStatus(this);
      }
    }
  }
}

class BattleSystem {
  constructor() {
    this.playerTeam = [];
    this.enemyTeam = [];
    this.turnQueue = [];
    this.currentEntity = null;
    this.isBattleActive = false;
    this.actionDeck = [];
  }
  init(playerConfig, levelId) {
    this.playerTeam = [];
    playerConfig.roster.forEach((charId, idx) => {
      if (charId && dataLoader.getCharacter(charId))
        this.playerTeam.push(new BattleEntity(`p_${idx}`, charId, true, idx));
    });
    this.actionDeck = playerConfig.deck;
    let enemyId = levelId;
    if (!dataLoader.getEnemy(enemyId)) enemyId = "boss_doll";
    this.enemyTeam = [new BattleEntity("e_0", enemyId, false, 0)];
    this.isBattleActive = true;
    this.turnQueue = [];
    UIManager.initBattle(this.playerTeam, this.enemyTeam);
    UIManager.updateCharacterPositions({ id: null }, [
      ...this.playerTeam,
      ...this.enemyTeam,
    ]);
    BoardSystem.init(this.playerTeam, this.actionDeck);
    SoundManager.startBGM();
    this.gameLoop();
  }
  surrender() {
    this.isBattleActive = false;
    SoundManager.stopBGM();
    SettingsManager.toggle(false);
    UIManager.showToast(Utils.getText("defeat"), true);
    SoundManager.playDefeat();
    setTimeout(() => {
      document.getElementById("battle-scene").classList.remove("active");
      document.getElementById("level-select-scene").classList.add("active");
    }, 1500);
  }
  predictActionOrder(count = 8) {
    let simEntities = [...this.playerTeam, ...this.enemyTeam]
      .filter((e) => !e.isFainted)
      .map((e) => ({
        id: e.id,
        name: e.name,
        isPlayer: e.isPlayer,
        element: e.element,
        spd: e.temp.spd,
        ap: e.ap,
        simAp: e.ap,
      }));
    let queue = [];
    let loopLimit = 0;
    if (this.currentEntity && !this.currentEntity.isFainted)
      queue.push({
        id: this.currentEntity.id,
        name: this.currentEntity.name,
        isPlayer: this.currentEntity.isPlayer,
        element: this.currentEntity.element,
        isCurrent: true,
      });
    while (queue.length < count && loopLimit < 5000) {
      loopLimit++;
      let ready = simEntities.filter((e) => e.simAp >= CONFIG.BASE_AP_GOAL);
      if (ready.length > 0) {
        ready.sort((a, b) => b.simAp - a.simAp);
        for (let e of ready) {
          if (queue.length >= count) break;
          queue.push(e);
          e.simAp -= CONFIG.BASE_AP_GOAL;
        }
      } else simEntities.forEach((e) => (e.simAp += e.spd));
    }
    return queue;
  }
  async gameLoop() {
    while (this.isBattleActive) {
      if (SettingsManager.isPaused) {
        await new Promise((r) => setTimeout(r, 200));
        continue;
      }
      if (this.checkEndCondition()) break;
      if (this.turnQueue.length === 0) this.tickTime();
      if (this.turnQueue.length > 0) {
        const entity = this.turnQueue.shift();
        this.currentEntity = entity;
        UIManager.highlightTurn(entity);
        UIManager.updateCharacterPositions(entity, [
          ...this.playerTeam,
          ...this.enemyTeam,
        ]);
        let order = this.predictActionOrder(8);
        UIManager.updateActionOrder(order, false);
        if (entity.isFainted) continue;
        if (entity.isPlayer) {
          BoardSystem.prepareBoardForCharacter(entity);
          await this.waitForPlayerInput();
        } else await this.executeAI(entity);

        if (!this.isBattleActive) break;

        entity.ap -= CONFIG.BASE_AP_GOAL;
        entity.resetTurn();
        BoardSystem.isLocked = true;
        let nextOrder = this.predictActionOrder(8);
        UIManager.updateActionOrder(nextOrder, true);
        await new Promise((r) => setTimeout(r, 600));
        BoardSystem.isLocked = false;
      }
    }
  }
  tickTime() {
    let loops = 0;
    while (this.turnQueue.length === 0 && loops < 10000) {
      let anyoneReady = false;
      [...this.playerTeam, ...this.enemyTeam].forEach((entity) => {
        if (entity.isFainted) return;
        entity.ap += entity.temp.spd;
        if (entity.ap >= CONFIG.BASE_AP_GOAL) {
          this.turnQueue.push(entity);
          anyoneReady = true;
        }
      });
      if (anyoneReady) {
        this.turnQueue.sort((a, b) => b.ap - a.ap);
      }
      loops++;
    }
  }
  waitForPlayerInput() {
    return new Promise((resolve) => {
      this.resolveTurnInput = resolve;
    });
  }
  executePlayerSkill(charEntity, actionId, count, isTriple) {
    SoundManager.playAttack();
    UIManager.playAttackAnim(charEntity);
    const skillData = charEntity.actions[actionId];
    if (!skillData) {
      this.resolveTurnInput();
      return;
    }
    const target =
      this.enemyTeam.find((e) => !e.isFainted) || this.enemyTeam[0];
    let dmgMult = isTriple ? 2 : 1;
    if (count > 3) dmgMult += (count - 3) * 0.5;
    setTimeout(() => {
      const descStr = skillData.desc.en || skillData.desc;
      if (descStr.includes("Dmg") || descStr.includes("伤")) {
        const dmgInfo = Utils.calcDamage(
          charEntity,
          target,
          charEntity.temp.atk * dmgMult,
          skillData.type,
          descStr.includes("True") || descStr.includes("真实"),
          false,
        );
        target.takeDamage(dmgInfo.hpDmg, dmgInfo.shieldDmg);
        this.triggerBreak(target, skillData.type);
      } else if (descStr.includes("Shield") || descStr.includes("盾"))
        charEntity.addShield(5 * dmgMult);
      if (this.resolveTurnInput) {
        this.resolveTurnInput();
        this.resolveTurnInput = null;
      }
    }, 300);
  }
  async executeAI(enemy) {
    await new Promise((r) => setTimeout(r, 800));
    while (SettingsManager.isPaused)
      await new Promise((r) => setTimeout(r, 200));

    if (!this.isBattleActive) return;

    const alivePlayers = this.playerTeam.filter((p) => !p.isFainted);
    if (alivePlayers.length > 0) {
      const target =
        alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
      const dmg = Utils.calcDamage(
        enemy,
        target,
        enemy.temp.atk,
        enemy.element,
        false,
        false,
      );
      UIManager.playAttackAnim(enemy);
      SoundManager.playAttack();
      setTimeout(() => {
        if (this.isBattleActive) {
          target.takeDamage(dmg.hpDmg, dmg.shieldDmg);
          UIManager.showFloatText(0, false, Utils.getText("attack"), "#f0f");
        }
      }, 300);
    }
  }
  triggerBreak(target, elementType) {
    if (!target.breaks[elementType]) return;
    target.breaks[elementType].count -= 1;
    UIManager.showFloatText(
      target.position,
      target.isPlayer,
      `Break -1 (${elementType})`,
      "#ffa",
    );
    if (target.breaks[elementType].count <= 0) {
      let breakDmg = target.breaks[elementType].dmg;
      target.takeDamage(breakDmg, 0, true);
      target.breaks[elementType].count = 10;
      UIManager.showFloatText(
        target.position,
        target.isPlayer,
        Utils.getText("break_trigger"),
        "gold",
      );
    }
  }
  checkEndCondition() {
    const playerAlive = this.playerTeam.some((p) => !p.isFainted);
    const enemyAlive = this.enemyTeam.some((e) => !e.isFainted);
    if (!playerAlive) {
      SoundManager.stopBGM();
      UIManager.showToast(Utils.getText("defeat"), true);
      SoundManager.playDefeat();
      this.isBattleActive = false;
      setTimeout(() => {
        document.getElementById("battle-scene").classList.remove("active");
        document.getElementById("level-select-scene").classList.add("active");
        SettingsManager.toggle(false);
      }, 2000);
      return true;
    }
    if (!enemyAlive) {
      SoundManager.stopBGM();
      UIManager.showToast(Utils.getText("victory"), true);
      SoundManager.playWin();
      this.isBattleActive = false;
      setTimeout(() => {
        document.getElementById("battle-scene").classList.remove("active");
        document.getElementById("level-select-scene").classList.add("active");
        SettingsManager.toggle(false);
      }, 2000);
      return true;
    }
    return false;
  }
}

class BoardSystem {
  static grid = [];
  static width = 10;
  static height = 10;
  static actionDeck = [];
  static playerTeam = [];
  static deckPool = [];
  static isLocked = false;
  static init(playerTeam, deckConfig) {
    this.playerTeam = playerTeam;
    this.deckPool = [];
    deckConfig.forEach((cfg) => {
      const charEntity = this.playerTeam.find(
        (p) => p.position === cfg.charIndex,
      );
      if (charEntity) {
        const actionData = charEntity.actions[cfg.actionId];
        if (!actionData) return;
        const element =
          actionData && actionData.type !== "none"
            ? actionData.type
            : charEntity.element;
        this.deckPool.push({
          charIndex: cfg.charIndex,
          actionId: cfg.actionId,
          element: element,
        });
      }
    });
    this.fillBoard(true);
    this.bindEvents();
    this.render();
  }
  static getRandomTile() {
    if (this.deckPool.length === 0) return null;
    const item =
      this.deckPool[Math.floor(Math.random() * this.deckPool.length)];
    return {
      id: Utils.uuid(),
      type: item.actionId,
      charIndex: item.charIndex,
      element: item.element,
      isMatch: false,
      justDropped: false,
      dropDistance: 0,
    };
  }
  static fillBoard(full = false) {
    if (full) {
      this.grid = [];
      for (let y = 0; y < this.height; y++) {
        let row = [];
        for (let x = 0; x < this.width; x++) row.push(this.getRandomTile());
        this.grid.push(row);
      }
    } else {
      for (let x = 0; x < this.width; x++) {
        let emptySlots = 0;
        for (let y = this.height - 1; y >= 0; y--) {
          if (this.grid[y][x] === null) emptySlots++;
          else if (emptySlots > 0) {
            this.grid[y + emptySlots][x] = this.grid[y][x];
            this.grid[y][x] = null;
            this.grid[y + emptySlots][x].dropDistance = emptySlots;
          }
        }
        for (let y = 0; y < emptySlots; y++) {
          this.grid[y][x] = this.getRandomTile();
          this.grid[y][x].dropDistance = emptySlots;
        }
      }
    }
  }
  static render() {
    const canvas = document.getElementById("grid-canvas");
    canvas.innerHTML = "";
    const activeCharIdx = game.battleSystem.currentEntity?.isPlayer
      ? game.battleSystem.currentEntity.position
      : -1;
    for (let y = 0; y < this.height; y++) {
      for (let x = 0; x < this.width; x++) {
        const tile = this.grid[y][x];
        if (!tile) continue;
        const div = document.createElement("div");
        div.className = "tile";
        div.dataset.x = x;
        div.dataset.y = y;
        if (tile.dropDistance > 0) {
          div.style.setProperty("--drop-dist", tile.dropDistance);
          div.classList.add("falling");
          tile.dropDistance = 0;
        }
        const isOwnedByActive = tile.charIndex === activeCharIdx;
        const isHighLight = activeCharIdx !== -1 ? isOwnedByActive : true;
        if (activeCharIdx !== -1 && !isOwnedByActive)
          div.classList.add("dimmed");
        else div.classList.add("highlighted");
        div.innerHTML = Utils.getTileSVG(tile.type, tile.element, isHighLight);
        canvas.appendChild(div);
      }
    }
  }
  static prepareBoardForCharacter(charEntity) {
    const charIdx = charEntity.position;
    let hasTiles = false;
    for (let y = 0; y < this.height; y++) {
      for (let x = 0; x < this.width; x++) {
        if (this.grid[y][x] && this.grid[y][x].charIndex === charIdx) {
          hasTiles = true;
          break;
        }
      }
    }
    if (!hasTiles) {
      UIManager.showToast(Utils.getText("refresh_board"), false);
      this.fillBoard(true);
    }
    this.render();
  }
  static bindEvents() {
    const oldCanvas = document.getElementById("grid-canvas");
    const newCanvas = oldCanvas.cloneNode(true);
    oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);

    let selected = null;
    let lastClickTime = 0;
    let lastClickTile = null;
    newCanvas.addEventListener("click", (e) => {
      if (this.isLocked) return;
      SoundManager.init();
      const el = e.target.closest(".tile");
      if (!el) return;
      const activeEntity = game.battleSystem.currentEntity;
      if (!activeEntity || !activeEntity.isPlayer) return;
      const x = parseInt(el.dataset.x);
      const y = parseInt(el.dataset.y);
      const tile = this.grid[y][x];
      const now = Date.now();
      const isMine = tile.charIndex === activeEntity.position;

      if (isMine && lastClickTile === tile && now - lastClickTime < 300) {
        SoundManager.playClick();
        this.handleElimination([{ x, y }], tile.type, false);
        lastClickTile = null;
        lastClickTime = 0;
        selected = null;
        this.clearSelection();
        return;
      }
      SoundManager.playClick();
      if (isMine) {
        lastClickTile = tile;
        lastClickTime = now;
      } else lastClickTile = null;

      if (!selected) {
        if (!isMine) return;
        selected = { x, y, el };
        el.classList.add("selected-swap");
      } else {
        const dist = Math.abs(selected.x - x) + Math.abs(selected.y - y);
        if (dist === 0) {
          this.clearSelection();
          selected = null;
          return;
        }
        if (dist === 1) {
          this.swapAndCheck(selected, { x, y });
          selected = null;
          this.clearSelection();
        } else {
          this.clearSelection();
          if (isMine) {
            selected = { x, y, el };
            el.classList.add("selected-swap");
          } else selected = null;
        }
      }
    });
  }
  static clearSelection() {
    document
      .querySelectorAll(".tile.selected-swap")
      .forEach((el) => el.classList.remove("selected-swap"));
  }
  static async swapAndCheck(pos1, pos2) {
    SoundManager.playSwap();
    const t1 = this.grid[pos1.y][pos1.x];
    const t2 = this.grid[pos2.y][pos2.x];
    this.grid[pos1.y][pos1.x] = t2;
    this.grid[pos2.y][pos2.x] = t1;
    this.render();
    const allMatches = this.findMatches();
    const activeCharIdx = game.battleSystem.currentEntity
      ? game.battleSystem.currentEntity.position
      : -1;
    const validActiveMatches = allMatches.filter((c) => {
      const tile = this.grid[c.y][c.x];
      return tile && tile.charIndex === activeCharIdx;
    });

    if (validActiveMatches.length > 0) {
      await new Promise((r) => setTimeout(r, 200));
      const sampleCoord = validActiveMatches[0];
      const matchSample = this.grid[sampleCoord.y][sampleCoord.x];
      this.handleElimination(allMatches, matchSample.type, true);
    } else {
      await new Promise((r) => setTimeout(r, 200));
      this.grid[pos1.y][pos1.x] = t1;
      this.grid[pos2.y][pos2.x] = t2;
      SoundManager.playSwap();
      this.render();
    }
  }
  static findMatches() {
    let matchedSet = new Set();
    for (let y = 0; y < this.height; y++) {
      for (let x = 0; x < this.width - 2; x++) {
        const t1 = this.grid[y][x],
          t2 = this.grid[y][x + 1],
          t3 = this.grid[y][x + 2];
        if (
          t1 &&
          t2 &&
          t3 &&
          t1.charIndex === t2.charIndex &&
          t2.charIndex === t3.charIndex &&
          t1.type === t2.type &&
          t2.type === t3.type
        ) {
          matchedSet.add(`${x},${y}`);
          matchedSet.add(`${x + 1},${y}`);
          matchedSet.add(`${x + 2},${y}`);
        }
      }
    }
    for (let x = 0; x < this.width; x++) {
      for (let y = 0; y < this.height - 2; y++) {
        const t1 = this.grid[y][x],
          t2 = this.grid[y + 1][x],
          t3 = this.grid[y + 2][x];
        if (
          t1 &&
          t2 &&
          t3 &&
          t1.charIndex === t2.charIndex &&
          t2.charIndex === t3.charIndex &&
          t1.type === t2.type &&
          t2.type === t3.type
        ) {
          matchedSet.add(`${x},${y}`);
          matchedSet.add(`${x},${y + 1}`);
          matchedSet.add(`${x},${y + 2}`);
        }
      }
    }
    return Array.from(matchedSet).map((s) => {
      const [x, y] = s.split(",").map(Number);
      return { x, y };
    });
  }
  static async handleElimination(coords, actionType, isMatch3) {
    SoundManager.playMatch();
    const canvas = document.getElementById("grid-canvas");
    const promises = coords.map((c) => {
      const el = canvas.querySelector(
        `.tile[data-x="${c.x}"][data-y="${c.y}"]`,
      );
      if (el) {
        el.classList.add("eliminating");
        return new Promise((resolve) => setTimeout(resolve, 300));
      }
      return Promise.resolve();
    });
    await Promise.all(promises);
    coords.forEach((c) => {
      this.grid[c.y][c.x] = null;
    });
    this.fillBoard();
    this.render();
    if (game.battleSystem.currentEntity)
      game.battleSystem.executePlayerSkill(
        game.battleSystem.currentEntity,
        actionType,
        coords.length,
        isMatch3,
      );
  }
}

class UIManager {
  static container = document.getElementById("ui-layer");
  static timelineQueue = document.querySelector(
    "#timeline-container .timeline-queue",
  );
  static prepScene = document.getElementById("prep-scene");
  static levelSelectScene = document.getElementById("level-select-scene");
  static battleScene = document.getElementById("battle-scene");
  static toast = document.getElementById("toast");

  static initBattle(pTeam, eTeam) {
    this.prepScene.classList.remove("active");
    this.levelSelectScene.classList.remove("active");
    this.battleScene.classList.add("active");
    ["p-pos-1", "p-pos-2", "p-pos-3", "e-pos-1", "e-pos-2", "e-pos-3"].forEach(
      (id) => {
        const el = document.getElementById(id);
        if (el) el.innerHTML = "";
      },
    );
    pTeam.forEach((p) => this.createHUD(p, p.position, true));
    eTeam.forEach((e) => this.createHUD(e, e.position, false));
    this.updateAll(pTeam.concat(eTeam));
  }
  static createHUD(entity, index, isPlayer) {
    const posId = isPlayer ? `p-pos-${index + 1}` : `e-pos-${index + 1}`;
    const container = document.getElementById(posId);
    const sprite = document.createElement("div");
    sprite.className = "sprite";
    sprite.innerHTML = this.getCharSpriteSVG(entity.templateId, entity.element);
    container.appendChild(sprite);
    const hud = document.createElement("div");
    hud.className = "char-hud";
    hud.id = `hud-${entity.id}`;
    hud.innerHTML = `<div class="hud-header"><div class="break-gauge" id="break-${
      entity.id
    }"></div><div class="char-slot-id">#${
      index + 1
    }</div><div class="char-name">${entity.name.substr(
      0,
      8,
    )}</div></div><div class="hp-bar-container"><div class="hp-bar-fill" id="hp-fill-${
      entity.id
    }"></div><div class="shield-bar-overlay" id="shield-fill-${
      entity.id
    }"></div><div class="hp-text" id="hp-val-${entity.id}">${
      entity.currentHp
    }/${entity.maxHp}</div></div>`;
    container.appendChild(hud);
    this.updateBreaks(entity);
  }
  static updateCharacterPositions(activeEntity, allEntities) {
    const P_POS = CONFIG.POSITIONS.PLAYER,
      E_POS = CONFIG.POSITIONS.ENEMY;
    allEntities.forEach((e) => {
      if (e.isFainted) return;
      const isCurrent = e.id === activeEntity.id;
      if (e.isPlayer) {
        const container = document.getElementById(`p-pos-${e.position + 1}`);
        if (container) {
          if (isCurrent) {
            container.style.left = P_POS.ACTIVE.left;
            container.style.bottom = P_POS.ACTIVE.bottom;
            container.style.zIndex = P_POS.ACTIVE.zIndex;
          } else {
            container.style.left = "";
            container.style.bottom = "";
            container.style.zIndex = "";
          }
        }
      } else {
        const container = document.getElementById(`e-pos-${e.position + 1}`);
        if (container) {
          if (isCurrent) {
            container.style.right = E_POS.ACTIVE.right;
            container.style.bottom = E_POS.ACTIVE.bottom;
            container.style.zIndex = E_POS.ACTIVE.zIndex;
          } else {
            container.style.right = "";
            container.style.bottom = "";
            container.style.zIndex = "";
          }
        }
      }
    });
  }
  static getCharSpriteSVG(templateId, element) {
    const color = CONFIG.COLORS[element] || "#ccc";
    const bodyColor = color,
      skinColor = "#ffccaa",
      outline = 'stroke="#000" stroke-width="2"';
    const baseSvg = (c) =>
      `<svg viewBox="0 0 64 128" width="100%" height="100%" preserveAspectRatio="xMidYMax">${c}</svg>`;
    let svgContent = "";
    if (templateId === "kai")
      svgContent = `<!-- Legs --><rect x="20" y="90" width="10" height="30" fill="#333" ${outline}/><rect x="34" y="90" width="10" height="30" fill="#333" ${outline}/><!-- Body --><path d="M16 50 h32 v40 h-32 z" fill="${bodyColor}" ${outline}/><!-- Head --><rect x="20" y="20" width="24" height="24" fill="${skinColor}" ${outline}/><!-- Hair --><path d="M18 18 h28 v10 h-28 z" fill="#cc0000" ${outline}/><!-- Tachi --><path d="M48 60 l20 -40 l4 4 l-20 40 z" fill="#aaa" ${outline}/><rect x="46" y="60" width="6" height="6" fill="#333" ${outline}/>`;
    else if (templateId === "sosa")
      svgContent = `<!-- Robe --><path d="M16 90 l-4 38 h40 l-4 -38 z" fill="#2e8b57" ${outline}/><!-- Body --><rect x="20" y="50" width="24" height="40" fill="${bodyColor}" ${outline}/><!-- Head --><circle cx="32" cy="32" r="14" fill="${skinColor}" ${outline}/><!-- Hat --><path d="M16 20 q16 -10 32 0" fill="none" stroke="#2e8b57" stroke-width="4"/>`;
    else if (templateId === "aya")
      svgContent = `<!-- Legs --><rect x="20" y="80" width="8" height="40" fill="#444" ${outline}/><rect x="36" y="80" width="8" height="40" fill="#444" ${outline}/><!-- Body --><rect x="18" y="45" width="28" height="35" fill="${bodyColor}" ${outline}/><!-- Head --><rect x="22" y="18" width="20" height="22" fill="${skinColor}" ${outline}/><!-- Bow --><path d="M10 40 q-10 20 0 40" fill="none" stroke="#8b4513" stroke-width="3"/><line x1="10" y1="40" x2="10" y2="80" stroke="#fff" stroke-width="1" opacity="0.5"/><!-- Dagger --><path d="M46 60 l10 10 l-4 4 l-10 -10 z" fill="#ccc" ${outline}/>`;
    else if (templateId.includes("boss"))
      svgContent = `<!-- Robe --><path d="M10 120 L20 50 h24 L54 120 z" fill="#220022" ${outline}/><!-- Ribcage --><rect x="24" y="50" width="16" height="20" fill="#ddd" ${outline}/><line x1="24" y1="55" x2="40" y2="55" stroke="#000" stroke-width="1"/><line x1="24" y1="60" x2="40" y2="60" stroke="#000" stroke-width="1"/><!-- Head --><rect x="22" y="20" width="20" height="22" fill="#eee" ${outline}/><rect x="26" y="28" width="4" height="4" fill="#000"/><rect x="34" y="28" width="4" height="4" fill="#000"/><path d="M22 20 l5 -10 l5 5 l5 -5 l5 10 z" fill="gold" ${outline}/><line x1="54" y1="30" x2="54" y2="120" stroke="#442200" stroke-width="4"/><circle cx="54" cy="25" r="6" fill="purple" ${outline}/>`;
    else if (templateId.includes("minion"))
      svgContent = `<!-- Legs --><rect x="24" y="90" width="4" height="30" fill="#eee" ${outline}/><rect x="36" y="90" width="4" height="30" fill="#eee" ${outline}/><!-- Ribcage --><rect x="22" y="50" width="20" height="30" fill="#eee" ${outline}/><line x1="22" y1="60" x2="42" y2="60" stroke="#000" stroke-width="1"/><line x1="22" y1="70" x2="42" y2="70" stroke="#000" stroke-width="1"/><circle cx="32" cy="35" r="10" fill="#eee" ${outline}/><rect x="28" y="32" width="3" height="3" fill="#000"/><rect x="33" y="32" width="3" height="3" fill="#000"/><path d="M10 60 h10 v-20 h4 v20 h10 v4 h-10 v20 h-4 v-20 h-10 z" fill="#bbb" ${outline}/>`;
    else
      svgContent = `<path d="M20 120 L25 40 L15 30 L49 30 L39 40 L44 120 z" fill="${color}" opacity="0.8" ${outline}/><circle cx="32" cy="20" r="12" fill="${color}" ${outline}/>`;
    return baseSvg(svgContent);
  }
  static updateBreaks(entity) {
    const div = document.getElementById(`break-${entity.id}`);
    if (!div) return;
    div.innerHTML = "";
    Object.keys(entity.breaks).forEach((type) => {
      const b = entity.breaks[type];
      const icon = document.createElement("div");
      icon.className = "break-icon";
      icon.style.color = CONFIG.COLORS[type];
      icon.innerHTML = `<svg viewBox="0 0 24 24" fill="${CONFIG.COLORS[type]}" stroke="#fff" stroke-width="1"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4z"/></svg><span class="break-count">${b.count}</span>`;
      div.appendChild(icon);
    });
  }
  static highlightTurn(entity) {
    document
      .querySelectorAll(".char-hud")
      .forEach((el) => el.classList.remove("active-turn"));
    const hud = document.getElementById(`hud-${entity.id}`);
    if (hud) hud.classList.add("active-turn");
  }
  static playAttackAnim(entity) {
    const hud = document.getElementById(`hud-${entity.id}`);
    if (!hud) return;
    const container = hud.parentElement;
    const sprite = container.querySelector(".sprite");
    if (sprite) {
      sprite.classList.remove("anim-attack-player", "anim-attack-enemy");
      void sprite.offsetWidth;
      if (entity.isPlayer) sprite.classList.add("anim-attack-player");
      else sprite.classList.add("anim-attack-enemy");
    }
  }
  static playHitAnim(entity, isHeavy) {
    const hud = document.getElementById(`hud-${entity.id}`);
    if (!hud) return;
    const container = hud.parentElement;
    const sprite = container.querySelector(".sprite");
    if (sprite) {
      sprite.classList.remove("anim-hit-player", "anim-hit-enemy");
      void sprite.offsetWidth;
      if (entity.isPlayer) sprite.classList.add("anim-hit-player");
      else sprite.classList.add("anim-hit-enemy");
    }
    if (isHeavy) {
      const field = document.getElementById("battlefield");
      field.classList.remove("camera-shake");
      void field.offsetWidth;
      field.classList.add("camera-shake");
    }
  }
  static playDeathAnim(entity) {
    const hud = document.getElementById(`hud-${entity.id}`);
    if (!hud) return;
    const container = hud.parentElement;
    const sprite = container.querySelector(".sprite");
    if (sprite) sprite.classList.add("anim-death");
  }
  static reviveEntity(entity) {
    const hud = document.getElementById(`hud-${entity.id}`);
    if (!hud) return;
    const container = hud.parentElement;
    const sprite = container.querySelector(".sprite");
    if (sprite) sprite.classList.remove("anim-death");
  }
  static updateAll(entities) {
    entities.forEach((e) => this.updateEntityStatus(e));
  }
  static updateEntityStatus(entity) {
    const hpFill = document.getElementById(`hp-fill-${entity.id}`);
    const hpVal = document.getElementById(`hp-val-${entity.id}`);
    const hud = document.getElementById(`hud-${entity.id}`);
    const shieldFill = document.getElementById(`shield-fill-${entity.id}`);
    if (!hpFill) return;
    const hpPct = Math.max(0, Math.min(1, entity.currentHp / entity.maxHp));
    const g = Math.floor(255 * hpPct);
    const b = Math.floor(255 * hpPct);
    hpFill.style.width = `${hpPct * 100}%`;
    hpFill.style.backgroundColor = `rgb(255, ${g}, ${b})`;
    hpVal.innerText = `${entity.currentHp}/${entity.maxHp}`;
    const shieldPct = Math.min(100, (entity.temp.shield / entity.maxHp) * 100);
    shieldFill.style.width = `${shieldPct}%`;
    if (entity.isFainted) hud.classList.add("fainted");
    else hud.classList.remove("fainted");
    if (
      entity.currentHp <= entity.maxHp * 0.1 &&
      !entity.isFainted &&
      entity.currentHp > 0
    )
      hud.classList.add("low-hp");
    else hud.classList.remove("low-hp");
    this.updateBreaks(entity);
  }
  static updateActionOrder(orderList, animate = false) {
    const container = document.querySelector(
      "#timeline-container .timeline-queue",
    );
    if (!container) return;
    if (animate) {
      const firstChild = container.firstElementChild;
      if (firstChild) {
        firstChild.classList.add("exit");
        const newItemData = orderList[orderList.length - 1];
        if (newItemData) {
          const newIcon = this.createOrderIcon(newItemData, orderList.length);
          newIcon.classList.add("enter");
          container.appendChild(newIcon);
        }
        setTimeout(() => {
          this.renderOrderList(container, orderList);
        }, 500);
      } else this.renderOrderList(container, orderList);
    } else this.renderOrderList(container, orderList);
  }
  static renderOrderList(container, orderList) {
    container.innerHTML = "";
    orderList.forEach((item, index) => {
      const icon = this.createOrderIcon(item, index + 1);
      container.appendChild(icon);
    });
  }
  static createOrderIcon(item, index) {
    const icon = document.createElement("div");
    icon.className = "order-icon";
    if (item.isCurrent) icon.classList.add("current");
    icon.style.borderColor = item.isPlayer ? "#4ade80" : "#ef4444";
    icon.innerText = item.name.charAt(0);
    const badge = document.createElement("div");
    badge.className = "order-badge";
    badge.innerText = index;
    icon.appendChild(badge);
    return icon;
  }
  static showDamage(posIndex, isPlayer, hpDmg, shieldDmg) {
    const posId = isPlayer ? `p-pos-${posIndex + 1}` : `e-pos-${posIndex + 1}`;
    const container = document.getElementById(posId);
    if (shieldDmg > 0)
      this.createFloatText(container, `-${shieldDmg}`, "#60a5fa", -20);
    if (hpDmg > 0)
      setTimeout(() => {
        this.createFloatText(container, `-${hpDmg}`, "#ef4444", 0);
      }, 200);
    else if (shieldDmg === 0 && hpDmg === 0)
      this.createFloatText(container, Utils.getText("block"), "#ccc", 0);
  }
  static showFloatText(posIndex, isPlayer, text, color) {
    const posId = isPlayer ? `p-pos-${posIndex + 1}` : `e-pos-${posIndex + 1}`;
    const container = document.getElementById(posId);
    if (container) this.createFloatText(container, text, color, -30);
  }
  static createFloatText(parent, text, color, yOffset) {
    const el = document.createElement("div");
    el.className = "pop-text";
    el.innerText = text;
    el.style.color = color;
    el.style.top = yOffset + "px";
    parent.appendChild(el);
    setTimeout(() => el.remove(), 1000);
  }
  static log(msg) {
    console.log(`[BATTLE] ${msg}`);
    const hint = document.getElementById("action-hint");
    if (hint) hint.innerText = msg;
  }
  static showToast(msg, persist = false) {
    this.toast.innerText = msg;
    this.toast.style.display = "block";
    if (!persist)
      setTimeout(() => {
        this.toast.style.display = "none";
      }, 2000);
  }
  static switchScene(sceneName) {
    document
      .querySelectorAll(".scene")
      .forEach((el) => el.classList.remove("active"));
    if (sceneName === "prep") this.prepScene.classList.add("active");
    else if (sceneName === "levelSelect")
      this.levelSelectScene.classList.add("active");
    else if (sceneName === "battle") this.battleScene.classList.add("active");
  }
}

class SettingsManager {
  static isPaused = false;
  static init() {
    const btn = document.getElementById("settings-btn");
    const modal = document.getElementById("settings-modal");
    const resumeBtn = document.getElementById("btn-resume");
    const volSlider = document.getElementById("vol-slider");
    const langBtn = document.getElementById("lang-switch-btn");
    const surrenderBtn = document.getElementById("btn-surrender");
    btn.onclick = () => {
      this.toggle(true);
      SoundManager.init();
    };
    resumeBtn.onclick = () => this.toggle(false);
    volSlider.oninput = (e) => {
      SoundManager.setVolume(e.target.value / 100);
    };
    langBtn.onclick = () => {
      LangManager.toggle();
    };
    surrenderBtn.onclick = () => {
      game.battleSystem.surrender();
    };
    LangManager.apply();
  }
  static toggle(show) {
    const modal = document.getElementById("settings-modal");
    const battleControls = document.getElementById("battle-controls");
    const isBattle = game.battleSystem.isBattleActive;
    if (show) {
      modal.classList.add("active");
      if (isBattle) {
        this.isPaused = true;
        battleControls.style.display = "block";
      } else {
        battleControls.style.display = "none";
      }
    } else {
      modal.classList.remove("active");
      this.isPaused = false;
    }
  }
}

class LangManager {
  static toggle() {
    CONFIG.LANGUAGE = CONFIG.LANGUAGE === "zh_cn" ? "en_us" : "zh_cn";
    if (window.i18n) {
      i18n.setLanguage(CONFIG.LANGUAGE);
    }
    this.apply();
    PrepManager.renderRosterPool();
    PrepManager.renderRoster();
    PrepManager.renderDeckBuilder();
  }
  static apply() {
    document.querySelectorAll("[data-i18n]").forEach((el) => {
      const key = el.dataset.i18n;
      el.innerText = Utils.getText(key);
    });
  }
}

class PrepManager {
  static config = { roster: [null, null, null], deck: [] };
  static init() {
    SettingsManager.init();
    this.loadConfig();
    this.renderRoster();
    this.renderRosterPool();
    this.renderDeckBuilder();
    document.getElementById("btn-to-level").onclick = () => {
      if (this.validate()) {
        this.saveConfig();
        UIManager.switchScene("levelSelect");
      }
    };
    document.getElementById("btn-back-prep").onclick = () => {
      UIManager.switchScene("prep");
    };
    document.getElementById("btn-start-battle").onclick = () => {
      game.startBattle(this.config);
    };
    window.addEventListener("resize", this.fitScreen);
    this.fitScreen();
  }
  static fitScreen() {
    const container = document.getElementById("game-container");
    const scale = Math.min(
      window.innerWidth / CONFIG.SCREEN_WIDTH,
      window.innerHeight / CONFIG.SCREEN_HEIGHT,
    );
    container.style.transform = `scale(${scale})`;
  }
  static loadConfig() {
    const saved = localStorage.getItem(CONFIG.STORAGE_KEY);
    if (saved) {
      try {
        const parsed = JSON.parse(saved);
        if (parsed.roster && parsed.roster.length === 3) this.config = parsed;
        else this.setDefaultRoster();
      } catch (e) {
        console.error("Save load failed", e);
        this.setDefaultRoster();
      }
    } else {
      this.setDefaultRoster();
      this.autoFillDeck();
    }
  }
  static setDefaultRoster() {
    this.config.roster = ["kai", "sosa", "aya"];
  }
  static autoFillDeck() {
    this.config.deck = [];
    this.config.roster.forEach((cid, idx) => {
      if (!cid) return;
      this.config.deck.push({ charIndex: idx, actionId: 1 });
      this.config.deck.push({ charIndex: idx, actionId: 2 });
    });
    if (this.config.roster[0])
      this.config.deck.push({ charIndex: 0, actionId: 3 });
    if (this.config.roster[1])
      this.config.deck.push({ charIndex: 1, actionId: 3 });
  }
  static saveConfig() {
    localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(this.config));
  }
  static renderRosterPool() {
    const pool = document.getElementById("roster-pool");
    pool.innerHTML = "";
    const charCodes = dataLoader.getAllCharacterCodes();
    charCodes.forEach((charId) => {
      const charData = dataLoader.getCharacter(charId);
      const div = document.createElement("div");
      div.className = "pool-item";
      const isInRoster = this.config.roster.includes(charId);
      if (isInRoster) div.classList.add("disabled");
      div.innerText = Utils.getText(charData.name);
      div.onclick = () => {
        if (!isInRoster) this.addCharToRoster(charId);
      };
      pool.appendChild(div);
    });
  }
  static renderRoster() {
    const slots = document.getElementById("team-slots");
    slots.innerHTML = "";
    this.config.roster.forEach((charId, idx) => {
      const div = document.createElement("div");
      div.className = "char-slot";
      if (charId) {
        div.classList.add("selected");
        const charData = dataLoader.getCharacter(charId);
        div.innerText = charData ? Utils.getText(charData.name) : charId;
        const hint = document.createElement("div");
        hint.className = "remove-hint";
        hint.innerText = "x";
        div.appendChild(hint);
        div.onclick = () => this.removeCharFromRoster(idx);
        div.title = Utils.getText("click_remove");
      } else {
        div.classList.add("empty");
        div.innerText = Utils.getText("click_add");
        div.style.color = "#555";
      }
      slots.appendChild(div);
    });
  }
  static addCharToRoster(charId) {
    const emptyIdx = this.config.roster.indexOf(null);
    if (emptyIdx !== -1) {
      this.config.roster[emptyIdx] = charId;
      this.refreshAll();
    } else UIManager.showToast("Roster Full", false);
  }
  static removeCharFromRoster(idx) {
    this.config.roster[idx] = null;
    this.config.deck = this.config.deck.filter((d) => d.charIndex !== idx);
    this.refreshAll();
  }
  static refreshAll() {
    this.renderRoster();
    this.renderRosterPool();
    this.renderDeckBuilder();
  }
  static renderDeckBuilder() {
    const container = document.getElementById("action-deck-ui");
    container.innerHTML = "";
    this.config.roster.forEach((charId, charIndex) => {
      if (!charId) return;
      const charData = dataLoader.getCharacter(charId);
      if (!charData || !charData.actions) return;
      Object.keys(charData.actions).forEach((actId) => {
        const act = charData.actions[actId];
        const btn = document.createElement("div");
        btn.className = "action-item";
        const inDeckIdx = this.config.deck.findIndex(
          (d) => d.charIndex === charIndex && d.actionId == actId,
        );
        if (inDeckIdx > -1) btn.classList.add("selected");
        btn.innerHTML = Utils.getTileSVG(
          actId,
          act.type !== "none" ? act.type : charData.element,
          true,
        );
        const dot = document.createElement("div");
        dot.className = "owner-dot";
        dot.style.background = ["red", "green", "blue"][charIndex];
        btn.appendChild(dot);
        btn.onclick = () => this.toggleDeckItem(charIndex, actId);
        container.appendChild(btn);
      });
    });
    document.getElementById("deck-count").innerText = this.config.deck.length;
    this.checkValidity();
  }
  static toggleDeckItem(charIndex, actionId) {
    const idx = this.config.deck.findIndex(
      (d) => d.charIndex === charIndex && d.actionId == actionId,
    );
    if (idx > -1) {
      this.config.deck.splice(idx, 1);
    } else {
      if (this.config.deck.length < 8)
        this.config.deck.push({ charIndex, actionId });
    }
    this.renderDeckBuilder();
  }
  static checkValidity() {
    const btn = document.getElementById("btn-to-level");
    btn.disabled = !this.validate();
  }
  static validate() {
    if (this.config.roster.some((c) => c === null)) return false;
    if (this.config.deck.length !== 8) return false;
    const hasC0 = this.config.deck.some((d) => d.charIndex === 0);
    const hasC1 = this.config.deck.some((d) => d.charIndex === 1);
    const hasC2 = this.config.deck.some((d) => d.charIndex === 2);
    return hasC0 && hasC1 && hasC2;
  }
}

const game = {
  battleSystem: new BattleSystem(),
  startBattle: (config) => {
    const levelId = document.getElementById("level-select").value;
    game.battleSystem.init(config, levelId);
  },
};

window.onload = async () => {
  // 初始化 i18n
  if (window.i18n) {
    await i18n.load();
    i18n.setLanguage(CONFIG.LANGUAGE);
  }

  // 加载游戏数据
  if (window.dataLoader) {
    console.log("[Game] Loading game data...");
    await dataLoader.loadAll();
    console.log("[Game] Game data loaded");
  }
};
