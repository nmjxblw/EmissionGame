<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>元素觉醒：霓虹三消</title>
    <style>
      :root {
        --bg-color: #000;
        --text-color: #fff;
        --fire-red: #ff3333;
        --water-blue: #00ccff;
        --leaf-green: #33ff33;
        --gold-yellow: #ffff00;
        --dark-silver: #4a4a4a; /* 暗银色 */
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }

      body {
        background-color: #0a0a0a;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        overflow: hidden;
        font-family: "PingFang SC", "Microsoft YaHei", sans-serif;
      }

      #game-container {
        width: 100%;
        height: 100%;
        max-width: 56.25vh; /* 9:16 ratio */
        max-height: 177.78vw;
        background-color: var(--bg-color);
        position: relative;
        display: flex;
        flex-direction: column;
        box-shadow: 0 0 50px rgba(0, 0, 0, 1);
      }

      #header {
        padding: 40px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: var(--text-color);
        z-index: 10;
      }

      .stat-box {
        text-align: center;
        background: rgba(255, 255, 255, 0.05);
        padding: 10px 20px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        min-width: 100px;
      }

      .stat-label {
        font-size: 12px;
        opacity: 0.6;
        margin-bottom: 2px;
        letter-spacing: 1px;
      }

      .stat-value {
        font-size: 24px;
        font-weight: bold;
        font-family: "Courier New", Courier, monospace;
        color: #fff;
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
      }

      #game-canvas {
        flex: 1;
        width: 100%;
        touch-action: none;
      }

      #overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: #fff;
        z-index: 100;
        cursor: pointer;
        text-align: center;
      }

      #overlay h1 {
        font-size: 32px;
        margin-bottom: 10px;
        letter-spacing: 4px;
        background: linear-gradient(
          to right,
          #ff3333,
          #00ccff,
          #33ff33,
          #ffff00
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      .btn-start {
        padding: 12px 45px;
        background: #fff;
        color: #000;
        border-radius: 4px;
        font-weight: bold;
        font-size: 18px;
        margin-top: 30px;
        transition: transform 0.2s;
      }

      .btn-start:active {
        transform: scale(0.95);
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <div id="header">
        <div class="stat-box">
          <div class="stat-label">SCORE</div>
          <div id="score" class="stat-value">0</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">TIME</div>
          <div id="timer" class="stat-value">60</div>
        </div>
      </div>

      <canvas id="game-canvas"></canvas>

      <div id="overlay">
        <h1 id="overlay-title">ELEMENTAL</h1>
        <p id="overlay-msg">点击屏幕唤醒元素</p>
        <div class="btn-start">START</div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("game-canvas");
      const ctx = canvas.getContext("2d");
      const scoreEl = document.getElementById("score");
      const timerEl = document.getElementById("timer");
      const overlay = document.getElementById("overlay");

      const ROWS = 10;
      const COLS = 10;
      const COLORS = [
        "#ff3333", // 火 (Fire)
        "#00ccff", // 水 (Water)
        "#33ff33", // 叶 (Leaf)
        "#ffff00", // 光 (Gold)
        "#4a4a4a", // 暗 (Dark Silver)
      ];

      let grid = [];
      let particles = [];
      let score = 0;
      let timeLeft = 60;
      let isPlaying = false;
      let isAnimating = false;
      let cellSize = 0;
      let padding = 10;
      let gridTop = 0;
      let timerId = null;
      let selectedCell = null;

      class Particle {
        constructor(x, y, color, type) {
          this.x = x;
          this.y = y;
          this.color = color;
          this.type = type; // 0:火, 1:水, 2:叶, 3:光, 4:暗
          this.vx = (Math.random() - 0.5) * 8;
          this.vy = (Math.random() - 0.5) * 8;
          this.life = 1.0;
          this.decay = 0.02 + Math.random() * 0.02;
          this.size = Math.random() * 4 + 2;
          this.angle = Math.random() * Math.PI * 2;
        }

        update() {
          if (this.type === 4) {
            // 黑洞吞噬：向中心收缩
            this.vx += (0 - this.vx) * 0.1;
            this.vy += (0 - this.vy) * 0.1;
            this.size *= 0.95;
          } else if (this.type === 0) {
            // 火：向上飘
            this.vy -= 0.2;
          } else if (this.type === 1) {
            // 水：受重力影响
            this.vy += 0.3;
          }

          this.x += this.vx;
          this.y += this.vy;
          this.life -= this.decay;
        }

        draw(ctx) {
          ctx.globalAlpha = this.life;
          ctx.fillStyle = this.color;
          ctx.shadowBlur = 10;
          ctx.shadowColor = this.color;

          if (this.type === 2) {
            // 花瓣效果
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle + this.life);
            ctx.beginPath();
            ctx.ellipse(0, 0, this.size, this.size / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          } else if (this.type === 3) {
            // 星形/十字闪光
            ctx.beginPath();
            ctx.moveTo(this.x - this.size * 2, this.y);
            ctx.lineTo(this.x + this.size * 2, this.y);
            ctx.moveTo(this.x, this.y - this.size * 2);
            ctx.lineTo(this.x, this.y + this.size * 2);
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 2;
            ctx.stroke();
          } else {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.shadowBlur = 0;
          ctx.globalAlpha = 1;
        }
      }

      function init() {
        resize();
        window.addEventListener("resize", resize);
        overlay.addEventListener("click", startGame);

        canvas.addEventListener("mousedown", handleInput);
        canvas.addEventListener(
          "touchstart",
          (e) => {
            e.preventDefault();
            handleInput(e.touches[0]);
          },
          { passive: false }
        );
      }

      function resize() {
        const container = canvas.parentElement;
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;

        cellSize = (canvas.width - padding * 2) / COLS;
        // 重新布局：以底端为锚点，底部预留 20px 边距
        gridTop = canvas.height - ROWS * cellSize - 20;
        draw();
      }

      function startGame() {
        if (isPlaying) return;
        score = 0;
        timeLeft = 60;
        scoreEl.innerText = score;
        timerEl.innerText = timeLeft;
        overlay.style.display = "none";

        createGrid();
        isPlaying = true;
        startTimer();
        gameLoop();
      }

      function createGrid() {
        grid = [];
        for (let r = 0; r < ROWS; r++) {
          grid[r] = [];
          for (let c = 0; c < COLS; c++) {
            grid[r][c] = {
              colorIndex: Math.floor(Math.random() * COLORS.length),
              scale: 1,
              yOffset: 0,
            };
          }
        }
        resolveInitialMatches();
      }

      function startTimer() {
        if (timerId) clearInterval(timerId);
        timerId = setInterval(() => {
          if (!isPlaying) return;
          timeLeft--;
          timerEl.innerText = timeLeft;
          if (timeLeft <= 0) endGame();
        }, 1000);
      }

      function endGame() {
        isPlaying = false;
        clearInterval(timerId);
        overlay.style.display = "flex";
        document.getElementById("overlay-title").innerText = "ELEMENTS SEALED";
        document.getElementById("overlay-msg").innerText = `SCORE: ${score}`;
      }

      function createExplosion(r, c, type) {
        const centerX = padding + c * cellSize + cellSize / 2;
        const centerY = gridTop + r * cellSize + cellSize / 2;
        const color = COLORS[type];
        const count = type === 4 ? 15 : 10; // 暗元素粒子稍微多一点

        for (let i = 0; i < count; i++) {
          particles.push(new Particle(centerX, centerY, color, type));
        }
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!grid || grid.length === 0) return;

        // 绘制粒子
        particles = particles.filter((p) => p.life > 0);
        particles.forEach((p) => {
          p.update();
          p.draw(ctx);
        });

        const pulse = Math.sin(Date.now() / 250) * 5 + 10;

        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            const cell = grid[r][c];
            if (!cell) continue;

            const x = padding + c * cellSize;
            const y = gridTop + r * cellSize + (cell.yOffset || 0);
            const drawSize = cellSize * 0.85 * cell.scale;
            const offset = (cellSize - drawSize) / 2;

            const color = COLORS[cell.colorIndex];

            ctx.save();
            // 银灰色特殊处理：加强内发光
            if (cell.colorIndex === 4) {
              ctx.shadowBlur = pulse;
              ctx.shadowColor = "#888";
            } else {
              ctx.shadowBlur = pulse;
              ctx.shadowColor = color;
            }

            ctx.fillStyle = color;

            // 绘制元素核心
            ctx.beginPath();
            const rr = 8; // 圆角
            ctx.roundRect
              ? ctx.roundRect(x + offset, y + offset, drawSize, drawSize, rr)
              : ctx.rect(x + offset, y + offset, drawSize, drawSize);
            ctx.fill();

            // 元素表面纹理
            ctx.shadowBlur = 0;
            ctx.fillStyle = "rgba(255,255,255,0.15)";
            ctx.beginPath();
            ctx.roundRect
              ? ctx.roundRect(
                  x + offset + 4,
                  y + offset + 4,
                  drawSize - 8,
                  drawSize / 3,
                  4
                )
              : ctx.rect(
                  x + offset + 4,
                  y + offset + 4,
                  drawSize - 8,
                  drawSize / 3
                );
            ctx.fill();

            ctx.restore();

            if (selectedCell && selectedCell.r === r && selectedCell.c === c) {
              ctx.strokeStyle = "#fff";
              ctx.lineWidth = 3;
              ctx.strokeRect(
                x + offset - 2,
                y + offset - 2,
                drawSize + 4,
                drawSize + 4
              );
            }
          }
        }
      }

      function handleInput(e) {
        if (!isPlaying || isAnimating) return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left - padding;
        const y = e.clientY - rect.top - gridTop;
        const c = Math.floor(x / cellSize);
        const r = Math.floor(y / cellSize);
        if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
          if (!selectedCell) {
            selectedCell = { r, c };
          } else {
            const dist =
              Math.abs(r - selectedCell.r) + Math.abs(c - selectedCell.c);
            if (dist === 1) swap(selectedCell.r, selectedCell.c, r, c);
            else selectedCell = { r, c };
          }
        }
      }

      async function swap(r1, c1, r2, c2) {
        isAnimating = true;
        const temp = grid[r1][c1];
        grid[r1][c1] = grid[r2][c2];
        grid[r2][c2] = temp;
        selectedCell = null;
        if (findMatches().length > 0) await resolveMatches();
        else {
          grid[r2][c2] = grid[r1][c1];
          grid[r1][c1] = temp;
        }
        isAnimating = false;
      }

      function findMatches() {
        const toMatch = new Set();
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS - 2; c++) {
            if (!grid[r][c] || !grid[r][c + 1] || !grid[r][c + 2]) continue;
            const color = grid[r][c].colorIndex;
            if (
              color === grid[r][c + 1].colorIndex &&
              color === grid[r][c + 2].colorIndex
            ) {
              toMatch.add(`${r},${c}`);
              toMatch.add(`${r},${c + 1}`);
              toMatch.add(`${r},${c + 2}`);
            }
          }
        }
        for (let c = 0; c < COLS; c++) {
          for (let r = 0; r < ROWS - 2; r++) {
            if (!grid[r][c] || !grid[r + 1][c] || !grid[r + 2][c]) continue;
            const color = grid[r][c].colorIndex;
            if (
              color === grid[r + 1][c].colorIndex &&
              color === grid[r + 2][c].colorIndex
            ) {
              toMatch.add(`${r},${c}`);
              toMatch.add(`${r + 1},${c}`);
              toMatch.add(`${r + 2},${c}`);
            }
          }
        }
        if (toMatch.size === 0) return [];
        const finalMatches = new Set();
        toMatch.forEach((pos) => {
          const [r, c] = pos.split(",").map(Number);
          if (grid[r][c])
            expandMatch(r, c, grid[r][c].colorIndex, finalMatches);
        });
        return Array.from(finalMatches).map((p) => {
          const [r, c] = p.split(",").map(Number);
          return { r, c };
        });
      }

      function expandMatch(r, c, color, matchedSet) {
        const key = `${r},${c}`;
        if (matchedSet.has(key) || r < 0 || r >= ROWS || c < 0 || c >= COLS)
          return;
        if (!grid[r][c] || grid[r][c].colorIndex !== color) return;
        matchedSet.add(key);
        expandMatch(r - 1, c, color, matchedSet);
        expandMatch(r + 1, c, color, matchedSet);
        expandMatch(r, c - 1, color, matchedSet);
        expandMatch(r, c + 1, color, matchedSet);
      }

      async function resolveMatches() {
        let matches = findMatches();
        while (matches.length > 0) {
          // 触发特效
          matches.forEach((m) => {
            if (grid[m.r][m.c])
              createExplosion(m.r, m.c, grid[m.r][m.c].colorIndex);
          });

          for (let i = 0; i <= 6; i++) {
            matches.forEach((m) => {
              if (grid[m.r][m.c]) grid[m.r][m.c].scale = 1 - i / 6;
            });
            draw();
            await new Promise((res) => setTimeout(res, 16));
          }
          score += matches.length;
          scoreEl.innerText = score;
          matches.forEach((m) => (grid[m.r][m.c] = null));
          await applyGravity();
          matches = findMatches();
        }
      }

      function resolveInitialMatches() {
        let matches = findMatches();
        while (matches.length > 0) {
          matches.forEach((m) => (grid[m.r][m.c] = null));
          for (let c = 0; c < COLS; c++) {
            for (let r = ROWS - 1; r >= 0; r--) {
              if (grid[r][c] === null) {
                for (let k = r - 1; k >= 0; k--) {
                  if (grid[k][c] !== null) {
                    grid[r][c] = grid[k][c];
                    grid[k][c] = null;
                    break;
                  }
                }
              }
              if (grid[r][c] === null)
                grid[r][c] = {
                  colorIndex: Math.floor(Math.random() * COLORS.length),
                  scale: 1,
                  yOffset: 0,
                };
            }
          }
          matches = findMatches();
        }
      }

      async function applyGravity() {
        for (let c = 0; c < COLS; c++) {
          let empty = 0;
          for (let r = ROWS - 1; r >= 0; r--) {
            if (grid[r][c] === null) empty++;
            else if (empty > 0) {
              grid[r + empty][c] = grid[r][c];
              grid[r][c] = null;
            }
          }
        }
        for (let c = 0; c < COLS; c++) {
          for (let r = 0; r < ROWS; r++) {
            if (grid[r][c] === null)
              grid[r][c] = {
                colorIndex: Math.floor(Math.random() * COLORS.length),
                scale: 1,
                yOffset: -canvas.height / 3,
              };
          }
        }
        for (let i = 0; i <= 10; i++) {
          for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
              if (grid[r][c] && grid[r][c].yOffset < 0) {
                grid[r][c].yOffset += canvas.height / 30;
                if (grid[r][c].yOffset > 0) grid[r][c].yOffset = 0;
              }
            }
          }
          draw();
          await new Promise((res) => setTimeout(res, 16));
        }
      }

      function gameLoop() {
        if (!isPlaying) return;
        draw();
        requestAnimationFrame(gameLoop);
      }

      init();
    </script>
  </body>
</html>
